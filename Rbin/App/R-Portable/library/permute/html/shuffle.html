<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Unrestricted and restricted permutations</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body><div class="container">

<table width="100%" summary="page for shuffle {permute}"><tr><td>shuffle {permute}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Unrestricted and restricted permutations</h2>

<h3>Description</h3>

<p>Unrestricted and restricted permutation designs for time series,
line transects, spatial grids and blocking factors.
</p>


<h3>Usage</h3>

<pre>
shuffle(n, control = how())

permute(i, n, control)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>n</code></td>
<td>
<p>numeric; the length of the returned vector of permuted
values. Usually the number of observations under consideration. May
also be any object that <code>nobs</code> knows about; see
<code><a href="../../permute/help/nobs-methods.html">nobs-methods</a></code>.</p>
</td></tr>
<tr valign="top"><td><code>control</code></td>
<td>
<p>a list of control values describing properties of the
permutation design, as returned by a call to <code>how</code>.</p>
</td></tr>
<tr valign="top"><td><code>i</code></td>
<td>
<p>integer; row of <code>control$all.perms</code> to return.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>shuffle</code> can generate permutations for a wide range of
restricted permutation schemes. A small selection of the available
combinations of options is provided in the Examples section below.
</p>
<p><code>permute</code> is a higher level utility function for use in a loop
within a function implementing a permutation test. The main purpose of
<code>permute</code> is to return the correct permutation in each iteration
of the loop, either a random permutation from the current design or
the next permutation from <code>control$all.perms</code> if it is not
<code>NULL</code> and <code>control$complete</code> is <code>TRUE</code>.
</p>


<h3>Value</h3>

<p>For <code>shuffle</code> a vector of length <code>n</code> containing a
permutation of the observations 1, ..., n using the permutation
scheme described by argument <code>control</code>.
</p>
<p>For <code>permute</code> the <code>i</code>th permutation from the set of all
permutations, or a random permutation from the design.
</p>


<h3>Author(s)</h3>

<p>Gavin Simpson</p>


<h3>References</h3>

<p><code>shuffle()</code> is modelled after the permutation schemes of Canoco
3.1 (ter Braak, 1990); see also Besag &amp; Clifford (1989).
</p>
<p>Besag, J. and Clifford, P. (1989) Generalized Monte Carlo significance
tests. <em>Biometrika</em> <strong>76</strong>; 633&ndash;642.
</p>
<p>ter Braak, C. J. F. (1990). <em>Update notes: CANOCO version
3.1</em>. Wageningen: Agricultural Mathematics Group. (UR).
</p>


<h3>See Also</h3>

<p><code><a href="../../permute/help/check.html">check</a></code>, a utility function for checking
permutation scheme described by <code><a href="../../permute/help/how.html">how</a></code>.</p>


<h3>Examples</h3>

<pre>

set.seed(1234)

## unrestricted permutations
shuffle(20)

## observations represent a time series of line transect
CTRL &lt;- how(within = Within(type = "series"))
shuffle(20, control = CTRL)

## observations represent a time series of line transect
## but with mirroring allowed
CTRL &lt;- how(within = Within(type = "series", mirror = TRUE))
shuffle(20, control = CTRL)

## observations represent a spatial grid, 5rx4c
nr &lt;- 5
nc &lt;- 4
CTRL &lt;- how(within = Within(type = "grid", ncol = nc, nrow = nr))
perms &lt;- shuffle(20, control = CTRL)
## view the permutation as a grid
matrix(matrix(1:20, nrow = nr, ncol = nc)[perms],
       ncol = nc, nrow = nr)

## random permutations in presence of strata
plots &lt;- Plots(strata = gl(4, 5))
CTRL &lt;- how(plots = plots, within = Within(type = "free"))
shuffle(20, CTRL)
## as above but same random permutation within strata
CTRL &lt;- how(plots = plots, within = Within(type = "free",
            constant = TRUE))
shuffle(20, CTRL)

## time series within each level of block
CTRL &lt;- how(plots = plots, within = Within(type = "series"))
shuffle(20, CTRL)
## as above, but  with same permutation for each level
CTRL &lt;- how(plots = plots, within = Within(type = "series",
            constant = TRUE))
shuffle(20, CTRL)

## spatial grids within each level of block, 4 x (5r x 5c)
nr &lt;- 5
nc &lt;- 5
nb &lt;- 4 ## number of blocks
plots &lt;- Plots(gl(nb, 25))
CTRL &lt;- how(plots = plots,
            within = Within(type = "grid", ncol = nc, nrow = nr))
shuffle(100, CTRL)
## as above, but with same permutation for each level
CTRL &lt;- how(plots = plots,
            within = Within(type = "grid", ncol = nc, nrow = nr,
                            constant = TRUE))
shuffle(100, CTRL)

## permuting levels of plots instead of observations
CTRL &lt;- how(plots = Plots(gl(4, 5), type = "free"),
            within = Within(type = "none"))
shuffle(20, CTRL)
## permuting levels of plots instead of observations
## but plots represent a time series
CTRL &lt;- how(plots = Plots(gl(4, 5), type = "series"),
            within = Within(type = "none"))
shuffle(20, CTRL)

## permuting levels of plots but plots represent a time series
## free permutation within plots
CTRL &lt;- how(plots = Plots(gl(4, 5), type = "series"),
            within = Within(type = "free"))
shuffle(20, CTRL)

## permuting within blocks
grp &lt;- gl(2, 10) # 2 groups of 10 samples each
CTRL &lt;- how(blocks = grp)
shuffle(length(grp), control = CTRL)

## Simple function using permute() to assess significance
## of a t.test  
pt.test &lt;- function(x, group, control) {
    ## function to calculate t
    t.statistic &lt;- function(x, y) {
        m &lt;- length(x)
        n &lt;- length(y)
        ## means and variances, but for speed
        xbar &lt;- mean(x)
        ybar &lt;- mean(y)
        xvar &lt;- var(x)
        yvar &lt;- var(y)
        pooled &lt;- sqrt(((m-1)*xvar + (n-1)*yvar) / (m+n-2))
        (xbar - ybar) / (pooled * sqrt(1/m + 1/n))
    }
    ## check the control object
    #control &lt;- check(x, control)$control ## FIXME
    ## number of observations
    Nobs &lt;- nobs(x)
    ## group names
    lev &lt;- names(table(group))
    ## vector to hold results, +1 because of observed t
    t.permu &lt;- numeric(length = control$nperm) + 1
    ## calculate observed t
    t.permu[1] &lt;- t.statistic(x[group == lev[1]], x[group == lev[2]])
    ## generate randomisation distribution of t
    for(i in seq_along(t.permu)) {
        ## return a permutation
        want &lt;- permute(i, Nobs, control)
        ## calculate permuted t
        t.permu[i+1] &lt;- t.statistic(x[want][group == lev[1]],
                                    x[want][group == lev[2]])
    }
    ## pval from permutation test
    pval &lt;- sum(abs(t.permu) &gt;= abs(t.permu[1])) / (control$nperm + 1)
    ## return value
    return(list(t.stat = t.permu[1], pval = pval))
}

## generate some data with slightly different means
set.seed(1234)
gr1 &lt;- rnorm(20, mean = 9)
gr2 &lt;- rnorm(20, mean = 10)
dat &lt;- c(gr1, gr2)
## grouping variable
grp &lt;- gl(2, 20, labels = paste("Group", 1:2))
## create the permutation design
control &lt;- how(nperm = 999, within = Within(type = "free"))
## perform permutation t test
perm.val &lt;- pt.test(dat, grp, control)
perm.val

## compare perm.val with the p-value from t.test()
t.test(dat ~ grp, var.equal = TRUE)
</pre>

<hr /><div style="text-align: center;">[Package <em>permute</em> version 0.9-5 <a href="00Index.html">Index</a>]</div>
</div></body></html>
