<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Principal Component Analysis (PCA) and Factor Analysis (FA)</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body><div class="container">

<table width="100%" summary="page for factor_analysis {parameters}"><tr><td>factor_analysis {parameters}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Principal Component Analysis (PCA) and Factor Analysis (FA)</h2>

<h3>Description</h3>

<p>The functions <code>principal_components()</code> and <code>factor_analysis()</code> can
be used to perform a principal component analysis (PCA) or a factor analysis
(FA). They return the loadings as a data frame, and various methods and
functions are available to access / display other information (see the
Details section).
</p>


<h3>Usage</h3>

<pre>
factor_analysis(
  x,
  n = "auto",
  rotation = "none",
  sort = FALSE,
  threshold = NULL,
  standardize = TRUE,
  cor = NULL,
  ...
)

principal_components(
  x,
  n = "auto",
  rotation = "none",
  sparse = FALSE,
  sort = FALSE,
  threshold = NULL,
  standardize = TRUE,
  ...
)

rotated_data(pca_results, verbose = TRUE)

## S3 method for class 'parameters_efa'
predict(
  object,
  newdata = NULL,
  names = NULL,
  keep_na = TRUE,
  verbose = TRUE,
  ...
)

## S3 method for class 'parameters_efa'
print(x, digits = 2, sort = FALSE, threshold = NULL, labels = NULL, ...)

## S3 method for class 'parameters_efa'
sort(x, ...)

closest_component(pca_results)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>x</code></td>
<td>
<p>A data frame or a statistical model.</p>
</td></tr>
<tr valign="top"><td><code>n</code></td>
<td>
<p>Number of components to extract. If <code>n="all"</code>, then <code>n</code> is set as
the number of variables minus 1 (<code>ncol(x)-1</code>). If <code>n="auto"</code> (default) or
<code>n=NULL</code>, the number of components is selected through <code><a href="../../parameters/help/n_factors.html">n_factors()</a></code> resp.
<code><a href="../../parameters/help/n_components.html">n_components()</a></code>. Else, if <code>n</code> is a number, <code>n</code> components are extracted.
If <code>n</code> exceeds number of variables in the data, it is automatically set to
the maximum number (i.e. <code>ncol(x)</code>). In <code><a href="../../parameters/help/reduce_parameters.html">reduce_parameters()</a></code>, can also
be <code>"max"</code>, in which case it will select all the components that are
maximally pseudo-loaded (i.e., correlated) by at least one variable.</p>
</td></tr>
<tr valign="top"><td><code>rotation</code></td>
<td>
<p>If not <code>"none"</code>, the PCA / FA will be computed using the
<strong>psych</strong> package. Possible options include <code>"varimax"</code>,
<code>"quartimax"</code>, <code>"promax"</code>, <code>"oblimin"</code>, <code>"simplimax"</code>,
or <code>"cluster"</code> (and more). See <code><a href="../../psych/help/fa.html">psych::fa()</a></code> for details.</p>
</td></tr>
<tr valign="top"><td><code>sort</code></td>
<td>
<p>Sort the loadings.</p>
</td></tr>
<tr valign="top"><td><code>threshold</code></td>
<td>
<p>A value between 0 and 1 indicates which (absolute) values
from the loadings should be removed. An integer higher than 1 indicates the
n strongest loadings to retain. Can also be <code>"max"</code>, in which case it
will only display the maximum loading per variable (the most simple
structure).</p>
</td></tr>
<tr valign="top"><td><code>standardize</code></td>
<td>
<p>A logical value indicating whether the variables should be
standardized (centered and scaled) to have unit variance before the
analysis (in general, such scaling is advisable).</p>
</td></tr>
<tr valign="top"><td><code>cor</code></td>
<td>
<p>An optional correlation matrix that can be used (note that the
data must still be passed as the first argument). If <code>NULL</code>, will
compute it by running <code>cor()</code> on the passed data.</p>
</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>
<p>Arguments passed to or from other methods.</p>
</td></tr>
<tr valign="top"><td><code>sparse</code></td>
<td>
<p>Whether to compute sparse PCA (SPCA, using <code><a href="../../sparsepca/help/spca.html">sparsepca::spca()</a></code>).
SPCA attempts to find sparse loadings (with few nonzero values), which improves
interpretability and avoids overfitting. Can be <code>TRUE</code> or <code>"robust"</code> (see
<code><a href="../../sparsepca/help/robspca.html">sparsepca::robspca()</a></code>).</p>
</td></tr>
<tr valign="top"><td><code>pca_results</code></td>
<td>
<p>The output of the <code>principal_components()</code> function.</p>
</td></tr>
<tr valign="top"><td><code>verbose</code></td>
<td>
<p>Toggle warnings.</p>
</td></tr>
<tr valign="top"><td><code>object</code></td>
<td>
<p>An object of class <code>parameters_pca</code> or <code>parameters_efa</code></p>
</td></tr>
<tr valign="top"><td><code>newdata</code></td>
<td>
<p>An optional data frame in which to look for variables with
which to predict. If omitted, the fitted values are used.</p>
</td></tr>
<tr valign="top"><td><code>names</code></td>
<td>
<p>Optional character vector to name columns of the returned data
frame.</p>
</td></tr>
<tr valign="top"><td><code>keep_na</code></td>
<td>
<p>Logical, if <code>TRUE</code>, predictions also return observations
with missing values from the original data, hence the number of rows of
predicted data and original data is equal.</p>
</td></tr>
<tr valign="top"><td><code>digits, labels</code></td>
<td>
<p>Arguments for <code>print()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Methods and Utilities</h4>


<ul>
<li> <p><code><a href="../../parameters/help/n_components.html">n_components()</a></code> and <code><a href="../../parameters/help/n_factors.html">n_factors()</a></code> automatically estimates the optimal
number of dimensions to retain.
</p>
</li>
<li> <p><code><a href="../../performance/help/check_factorstructure.html">performance::check_factorstructure()</a></code> checks the suitability of the
data for factor analysis using the sphericity (see
<code><a href="../../performance/help/check_factorstructure.html">performance::check_sphericity_bartlett()</a></code>) and the KMO (see
<code><a href="../../performance/help/check_factorstructure.html">performance::check_kmo()</a></code>) measure.
</p>
</li>
<li> <p><code><a href="../../performance/help/check_itemscale.html">performance::check_itemscale()</a></code> computes various measures of internal
consistencies applied to the (sub)scales (i.e., components) extracted from
the PCA.
</p>
</li>
<li><p> Running <code>summary()</code> returns information related to each component/factor,
such as the explained variance and the Eivenvalues.
</p>
</li>
<li><p> Running <code><a href="../../parameters/help/get_scores.html">get_scores()</a></code> computes scores for each subscale.
</p>
</li>
<li><p> Running <code><a href="../../parameters/help/closest_component.html">closest_component()</a></code> will return a numeric vector with the
assigned component index for each column from the original data frame.
</p>
</li>
<li><p> Running <code><a href="../../parameters/help/rotated_data.html">rotated_data()</a></code> will return the rotated data, including missing
values, so it matches the original data frame.
</p>
</li>
<li><p> Running
<a href="https://easystats.github.io/see/articles/parameters.html#principal-component-analysis"><code>plot()</code></a>
visually displays the loadings (that requires the
<a href="https://easystats.github.io/see/"><strong>see</strong>-package</a> to work).
</p>
</li></ul>




<h4>Complexity</h4>

<p>Complexity represents the number of latent components needed to account
for the observed variables. Whereas a perfect simple structure solution
has a complexity of 1 in that each item would only load on one factor,
a solution with evenly distributed items has a complexity greater than 1
(<em>Hofman, 1978; Pettersson and Turkheimer, 2010</em>).
</p>



<h4>Uniqueness</h4>

<p>Uniqueness represents the variance that is 'unique' to the variable and
not shared with other variables. It is equal to <code style="white-space: pre;">1 – communality</code>
(variance that is shared with other variables). A uniqueness of <code>0.20</code>
suggests that <code style="white-space: pre;">20%</code> or that variable's variance is not shared with other
variables in the overall factor model. The greater 'uniqueness' the lower
the relevance of the variable in the factor model.
</p>



<h4>MSA</h4>

<p>MSA represents the Kaiser-Meyer-Olkin Measure of Sampling Adequacy
(<em>Kaiser and Rice, 1974</em>) for each item. It indicates whether there is
enough data for each factor give reliable results for the PCA. The value
should be &gt; 0.6, and desirable values are &gt; 0.8 (<em>Tabachnick and Fidell, 2013</em>).
</p>



<h4>PCA or FA?</h4>

<p>There is a simplified rule of thumb that may help do decide whether to run
a factor analysis or a principal component analysis:
</p>

<ul>
<li><p> Run <em>factor analysis</em> if you assume or wish to test a theoretical model of
<em>latent factors</em> causing observed variables.
</p>
</li>
<li><p> Run <em>principal component analysis</em> If you want to simply <em>reduce</em> your
correlated observed variables to a smaller set of important independent
composite variables.
</p>
</li></ul>

<p>(Source: <a href="https://stats.stackexchange.com/q/1576/54740">CrossValidated</a>)
</p>



<h4>Computing Item Scores</h4>

<p>Use <code><a href="../../parameters/help/get_scores.html">get_scores()</a></code> to compute scores for the &quot;subscales&quot; represented by the
extracted principal components. <code>get_scores()</code> takes the results from
<code>principal_components()</code> and extracts the variables for each component found
by the PCA. Then, for each of these &quot;subscales&quot;, raw means are calculated
(which equals adding up the single items and dividing by the number of items).
This results in a sum score for each component from the PCA, which is on the
same scale as the original, single items that were used to compute the PCA.
One can also use <code>predict()</code> to back-predict scores for each component,
to which one can provide <code>newdata</code> or a vector of <code>names</code> for the components.
</p>



<h4>Explained Variance and Eingenvalues</h4>

<p>Use <code>summary()</code> to get the Eigenvalues and the explained variance for each
extracted component. The eigenvectors and eigenvalues represent the &quot;core&quot;
of a PCA: The eigenvectors (the principal components) determine the
directions of the new feature space, and the eigenvalues determine their
magnitude. In other words, the eigenvalues explain the variance of the
data along the new feature axes.
</p>



<h3>Value</h3>

<p>A data frame of loadings.
</p>


<h3>References</h3>


<ul>
<li><p> Kaiser, H.F. and Rice. J. (1974). Little jiffy, mark iv. Educational
and Psychological Measurement, 34(1):111–117
</p>
</li>
<li><p> Hofmann, R. (1978). Complexity and simplicity as objective indices
descriptive of factor solutions. Multivariate Behavioral Research, 13:2,
247-250, doi: <a href="https://doi.org/10.1207/s15327906mbr1302_9">10.1207/s15327906mbr1302_9</a>
</p>
</li>
<li><p> Pettersson, E., &amp; Turkheimer, E. (2010). Item selection, evaluation,
and simple structure in personality data. Journal of research in
personality, 44(4), 407-420, doi: <a href="https://doi.org/10.1016/j.jrp.2010.03.002">10.1016/j.jrp.2010.03.002</a>
</p>
</li>
<li><p> Tabachnick, B. G., and Fidell, L. S. (2013). Using multivariate
statistics (6th ed.). Boston: Pearson Education.
</p>
</li></ul>



<h3>Examples</h3>

<pre>

library(parameters)


# Principal Component Analysis (PCA) -------------------
principal_components(mtcars[, 1:7], n = "all", threshold = 0.2)

# Automated number of components
principal_components(mtcars[, 1:4], n = "auto")

# Sparse PCA
principal_components(mtcars[, 1:7], n = 4, sparse = TRUE)
principal_components(mtcars[, 1:7], n = 4, sparse = "robust")

# Rotated PCA
principal_components(mtcars[, 1:7],
  n = 2, rotation = "oblimin",
  threshold = "max", sort = TRUE
)
principal_components(mtcars[, 1:7], n = 2, threshold = 2, sort = TRUE)

pca &lt;- principal_components(mtcars[, 1:5], n = 2, rotation = "varimax")
pca # Print loadings
summary(pca) # Print information about the factors
predict(pca, names = c("Component1", "Component2")) # Back-predict scores

# which variables from the original data belong to which extracted component?
closest_component(pca)


# Factor Analysis (FA) ------------------------

factor_analysis(mtcars[, 1:7], n = "all", threshold = 0.2)
factor_analysis(mtcars[, 1:7], n = 2, rotation = "oblimin", threshold = "max", sort = TRUE)
factor_analysis(mtcars[, 1:7], n = 2, threshold = 2, sort = TRUE)

efa &lt;- factor_analysis(mtcars[, 1:5], n = 2)
summary(efa)
predict(efa, verbose = FALSE)


# Automated number of components
factor_analysis(mtcars[, 1:4], n = "auto")


</pre>

<hr /><div style="text-align: center;">[Package <em>parameters</em> version 0.21.6 <a href="00Index.html">Index</a>]</div>
</div></body></html>
