<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Outliers detection (check for influential observations)</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body><div class="container">

<table width="100%" summary="page for check_outliers {performance}"><tr><td>check_outliers {performance}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Outliers detection (check for influential observations)</h2>

<h3>Description</h3>

<p>Checks for and locates influential observations (i.e.,
&quot;outliers&quot;) via several distance and/or clustering methods. If several
methods are selected, the returned &quot;Outlier&quot; vector will be a composite
outlier score, made of the average of the binary (0 or 1) results of each
method. It represents the probability of each observation of being
classified as an outlier by at least one method. The decision rule used by
default is to classify as outliers observations which composite outlier
score is superior or equal to 0.5 (i.e., that were classified as outliers
by at least half of the methods). See the <strong>Details</strong> section below
for a description of the methods.
</p>


<h3>Usage</h3>

<pre>
check_outliers(x, ...)

## Default S3 method:
check_outliers(
  x,
  method = c("cook", "pareto"),
  threshold = NULL,
  ID = NULL,
  verbose = TRUE,
  ...
)

## S3 method for class 'numeric'
check_outliers(x, method = "zscore_robust", threshold = NULL, ...)

## S3 method for class 'data.frame'
check_outliers(x, method = "mahalanobis", threshold = NULL, ID = NULL, ...)

## S3 method for class 'performance_simres'
check_outliers(
  x,
  type = "default",
  iterations = 100,
  alternative = "two.sided",
  ...
)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>x</code></td>
<td>
<p>A model, a data.frame, a <code>performance_simres</code> <code><a href="../../performance/help/simulate_residuals.html">simulate_residuals()</a></code>
or a <code>DHARMa</code> object.</p>
</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>
<p>When <code>method = "ics"</code>, further arguments in <code>...</code> are passed
down to <code><a href="../../ICSOutlier/help/ics.outlier.html">ICSOutlier::ics.outlier()</a></code>. When <code>method = "mahalanobis"</code>,
they are  passed down to <code><a href="../../stats/help/mahalanobis.html">stats::mahalanobis()</a></code>. <code>percentage_central</code> can
be specified when <code>method = "mcd"</code>. For objects of class <code>performance_simres</code>
or <code>DHARMa</code>, further arguments are passed down to <code>DHARMa::testOutliers()</code>.</p>
</td></tr>
<tr valign="top"><td><code>method</code></td>
<td>
<p>The outlier detection method(s). Can be <code>"all"</code> or some of
<code>"cook"</code>, <code>"pareto"</code>, <code>"zscore"</code>, <code>"zscore_robust"</code>, <code>"iqr"</code>, <code>"ci"</code>, <code>"eti"</code>,
<code>"hdi"</code>, <code>"bci"</code>, <code>"mahalanobis"</code>, <code>"mahalanobis_robust"</code>, <code>"mcd"</code>, <code>"ics"</code>,
<code>"optics"</code> or <code>"lof"</code>.</p>
</td></tr>
<tr valign="top"><td><code>threshold</code></td>
<td>
<p>A list containing the threshold values for each method (e.g.
<code>list('mahalanobis' = 7, 'cook' = 1)</code>), above which an observation is
considered as outlier. If <code>NULL</code>, default values will be used (see
'Details'). If a numeric value is given, it will be used as the threshold
for any of the method run.</p>
</td></tr>
<tr valign="top"><td><code>ID</code></td>
<td>
<p>Optional, to report an ID column along with the row number.</p>
</td></tr>
<tr valign="top"><td><code>verbose</code></td>
<td>
<p>Toggle warnings.</p>
</td></tr>
<tr valign="top"><td><code>type</code></td>
<td>
<p>Type of method to test for outliers. Can be one of <code>"default"</code>,
<code>"binomial"</code> or <code>"bootstrap"</code>. Only applies when <code>x</code> is an object returned
by <code>simulate_residuals()</code> or of class <code>DHARMa</code>. See 'Details' in
<code>?DHARMa::testOutliers</code> for a detailed description of the types.</p>
</td></tr>
<tr valign="top"><td><code>iterations</code></td>
<td>
<p>Number of simulations to run.</p>
</td></tr>
<tr valign="top"><td><code>alternative</code></td>
<td>
<p>A character string specifying the alternative hypothesis.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Outliers can be defined as particularly influential observations.
Most methods rely on the computation of some distance metric, and the
observations greater than a certain threshold are considered outliers.
Importantly, outliers detection methods are meant to provide information to
consider for the researcher, rather than to be an automatized procedure
which mindless application is a substitute for thinking.
</p>
<p>An <strong>example sentence</strong> for reporting the usage of the composite method
could be:
</p>
<p><em>&quot;Based on a composite outlier score (see the 'check_outliers' function
in the 'performance' R package; Lüdecke et al., 2021) obtained via the joint
application of multiple outliers detection algorithms (Z-scores, Iglewicz,
1993; Interquartile range (IQR); Mahalanobis distance, Cabana, 2019; Robust
Mahalanobis distance, Gnanadesikan and Kettenring, 1972; Minimum Covariance
Determinant, Leys et al., 2018; Invariant Coordinate Selection, Archimbaud et
al., 2018; OPTICS, Ankerst et al., 1999; Isolation Forest, Liu et al. 2008;
and Local Outlier Factor, Breunig et al., 2000), we excluded n participants
that were classified as outliers by at least half of the methods used.&quot;</em>
</p>


<h3>Value</h3>

<p>A logical vector of the detected outliers with a nice printing
method: a check (message) on whether outliers were detected or not. The
information on the distance measure and whether or not an observation is
considered as outlier can be recovered with the <a href="../../base/html/as.data.frame.html">as.data.frame</a>
function. Note that the function will (silently) return a vector of <code>FALSE</code>
for non-supported data types such as character strings.
</p>


<h3>Model-specific methods</h3>


<ul>
<li> <p><strong>Cook's Distance</strong>:
Among outlier detection methods, Cook's distance and leverage are less
common than the basic Mahalanobis distance, but still used. Cook's distance
estimates the variations in regression coefficients after removing each
observation, one by one (Cook, 1977). Since Cook's distance is in the metric
of an F distribution with p and n-p degrees of freedom, the median point of
the quantile distribution can be used as a cut-off (Bollen, 1985). A common
approximation or heuristic is to use 4 divided by the numbers of
observations, which usually corresponds to a lower threshold (i.e., more
outliers are detected). This only works for frequentist models. For Bayesian
models, see <code>pareto</code>.
</p>
</li>
<li> <p><strong>Pareto</strong>:
The reliability and approximate convergence of Bayesian models can be
assessed using the estimates for the shape parameter k of the generalized
Pareto distribution. If the estimated tail shape parameter k exceeds 0.5, the
user should be warned, although in practice the authors of the <strong>loo</strong>
package observed good performance for values of k up to 0.7 (the default
threshold used by <code>performance</code>).
</p>
</li></ul>



<h3>Univariate methods</h3>


<ul>
<li> <p><strong>Z-scores</strong> <code style="white-space: pre;">("zscore", "zscore_robust")</code>:
The Z-score, or standard score, is a way of describing a data point as
deviance from a central value, in terms of standard deviations from the mean
(<code>"zscore"</code>) or, as it is here the case (<code>"zscore_robust"</code>) by
default (Iglewicz, 1993), in terms of Median Absolute Deviation (MAD) from
the median (which are robust measures of dispersion and centrality). The
default threshold to classify outliers is 1.959 (<code>threshold = list("zscore" = 1.959)</code>),
corresponding to the 2.5% (<code>qnorm(0.975)</code>) most extreme observations
(assuming the data is normally distributed). Importantly, the Z-score
method is univariate: it is computed column by column. If a dataframe is
passed, the Z-score is calculated for each variable separately, and the
maximum (absolute) Z-score is kept for each observations. Thus, all
observations that are extreme on at least one variable might be detected
as outliers. Thus, this method is not suited for high dimensional data
(with many columns), returning too liberal results (detecting many outliers).
</p>
</li>
<li> <p><strong>IQR</strong> <code>("iqr")</code>:
Using the IQR (interquartile range) is a robust method developed by John
Tukey, which often appears in box-and-whisker plots (e.g., in
<a href="../../ggplot2/help/geom_boxplot.html">ggplot2::geom_boxplot</a>). The interquartile range is the range between the first
and the third quartiles. Tukey considered as outliers any data point that
fell outside of either 1.5 times (the default threshold is 1.7) the IQR below
the first or above the third quartile. Similar to the Z-score method, this is
a univariate method for outliers detection, returning outliers detected for
at least one column, and might thus not be suited to high dimensional data.
The distance score for the IQR is the absolute deviation from the median of
the upper and lower IQR thresholds. Then, this value is divided by the IQR
threshold, to “standardize” it and facilitate interpretation.
</p>
</li>
<li> <p><strong>CI</strong> <code style="white-space: pre;">("ci", "eti", "hdi", "bci")</code>:
Another univariate method is to compute, for each variable, some sort of
&quot;confidence&quot; interval and consider as outliers values lying beyond the edges
of that interval. By default, <code>"ci"</code> computes the Equal-Tailed Interval
(<code>"eti"</code>), but other types of intervals are available, such as Highest
Density Interval (<code>"hdi"</code>) or the Bias Corrected and Accelerated
Interval (<code>"bci"</code>). The default threshold is <code>0.95</code>, considering
as outliers all observations that are outside the 95% CI on any of the
variable. See <code><a href="../../bayestestR/help/ci.html">bayestestR::ci()</a></code> for more details
about the intervals. The distance score for the CI methods is the absolute
deviation from the median of the upper and lower CI thresholds. Then, this
value is divided by the difference between the upper and lower CI bounds
divided by two, to “standardize” it and facilitate interpretation.
</p>
</li></ul>



<h3>Multivariate methods</h3>


<ul>
<li> <p><strong>Mahalanobis Distance</strong>:
Mahalanobis distance (Mahalanobis, 1930) is often used for multivariate
outliers detection as this distance takes into account the shape of the
observations. The default <code>threshold</code> is often arbitrarily set to some
deviation (in terms of SD or MAD) from the mean (or median) of the
Mahalanobis distance. However, as the Mahalanobis distance can be
approximated by a Chi squared distribution (Rousseeuw and Van Zomeren, 1990),
we can use the alpha quantile of the chi-square distribution with k degrees
of freedom (k being the number of columns). By default, the alpha threshold
is set to 0.025 (corresponding to the 2.5\
Cabana, 2019). This criterion is a natural extension of the median plus or
minus a coefficient times the MAD method (Leys et al., 2013).
</p>
</li>
<li> <p><strong>Robust Mahalanobis Distance</strong>:
A robust version of Mahalanobis distance using an Orthogonalized
Gnanadesikan-Kettenring pairwise estimator (Gnanadesikan and Kettenring,
1972). Requires the <strong>bigutilsr</strong> package. See the <code><a href="../../bigutilsr/help/covrob_ogk.html">bigutilsr::dist_ogk()</a></code>
function.
</p>
</li>
<li> <p><strong>Minimum Covariance Determinant (MCD)</strong>:
Another robust version of Mahalanobis. Leys et al. (2018) argue that
Mahalanobis Distance is not a robust way to determine outliers, as it uses
the means and covariances of all the data - including the outliers - to
determine individual difference scores. Minimum Covariance Determinant
calculates the mean and covariance matrix based on the most central subset of
the data (by default, 66\
is deemed to be a more robust method of identifying and removing outliers
than regular Mahalanobis distance.
This method has a <code>percentage_central</code> argument that allows specifying
the breakdown point (0.75, the default, is recommended by Leys et al. 2018,
but a commonly used alternative is 0.50).
</p>
</li>
<li> <p><strong>Invariant Coordinate Selection (ICS)</strong>:
The outlier are detected using ICS, which by default uses an alpha threshold
of 0.025 (corresponding to the 2.5\
value for outliers classification. Refer to the help-file of
<code><a href="../../ICSOutlier/help/ics.outlier.html">ICSOutlier::ics.outlier()</a></code> to get more details about this procedure.
Note that <code>method = "ics"</code> requires both <strong>ICS</strong> and <strong>ICSOutlier</strong>
to be installed, and that it takes some time to compute the results. You
can speed up computation time using parallel computing. Set the number of
cores to use with <code>options(mc.cores = 4)</code> (for example).
</p>
</li>
<li> <p><strong>OPTICS</strong>:
The Ordering Points To Identify the Clustering Structure (OPTICS) algorithm
(Ankerst et al., 1999) is using similar concepts to DBSCAN (an unsupervised
clustering technique that can be used for outliers detection). The threshold
argument is passed as <code>minPts</code>, which corresponds to the minimum size
of a cluster. By default, this size is set at 2 times the number of columns
(Sander et al., 1998). Compared to the other techniques, that will always
detect several outliers (as these are usually defined as a percentage of
extreme values), this algorithm functions in a different manner and won't
always detect outliers. Note that <code>method = "optics"</code> requires the
<strong>dbscan</strong> package to be installed, and that it takes some time to compute
the results.
</p>
</li>
<li> <p><strong>Local Outlier Factor</strong>:
Based on a K nearest neighbors algorithm, LOF compares the local density of
a point to the local densities of its neighbors instead of computing a
distance from the center (Breunig et al., 2000). Points that have a
substantially lower density than their neighbors are considered outliers. A
LOF score of approximately 1 indicates that density around the point is
comparable to its neighbors. Scores significantly larger than 1 indicate
outliers. The default threshold of 0.025 will classify as outliers the
observations located at <code style="white-space: pre;">qnorm(1-0.025) * SD)</code> of the log-transformed
LOF distance. Requires the <strong>dbscan</strong> package.
</p>
</li></ul>



<h3>Methods for simulated residuals</h3>

<p>The approach for detecting outliers based on simulated residuals differs
from the traditional methods and may not be detecting outliers as expected.
Literally, this approach compares observed to simulated values. However, we
do not know the deviation of the observed data to the model expectation, and
thus, the term &quot;outlier&quot; should be taken with a grain of salt. It refers to
&quot;simulation outliers&quot;. Basically, the comparison tests whether on observed
data point is outside the simulated range. It is strongly recommended to read
the related documentations in the <strong>DHARMa</strong> package, e.g. <code>?DHARMa::testOutliers</code>.
</p>


<h3>Threshold specification</h3>

<p>Default thresholds are currently specified as follows:
</p>
<div class="sourceCode"><pre>list(
  zscore = stats::qnorm(p = 1 - 0.001 / 2),
  zscore_robust = stats::qnorm(p = 1 - 0.001 / 2),
  iqr = 1.7,
  ci = 1 - 0.001,
  eti = 1 - 0.001,
  hdi = 1 - 0.001,
  bci = 1 - 0.001,
  cook = stats::qf(0.5, ncol(x), nrow(x) - ncol(x)),
  pareto = 0.7,
  mahalanobis = stats::qchisq(p = 1 - 0.001, df = ncol(x)),
  mahalanobis_robust = stats::qchisq(p = 1 - 0.001, df = ncol(x)),
  mcd = stats::qchisq(p = 1 - 0.001, df = ncol(x)),
  ics = 0.001,
  optics = 2 * ncol(x),
  lof = 0.001
)
</pre></div>


<h3>Meta-analysis models</h3>

<p>For meta-analysis models (e.g. objects of class <code>rma</code> from the <em>metafor</em>
package or <code>metagen</code> from package <em>meta</em>), studies are defined as outliers
when their confidence interval lies outside the confidence interval of the
pooled effect.
</p>


<h3>Note</h3>

<p>There is also a
<a href="https://easystats.github.io/see/articles/performance.html"><code>plot()</code>-method</a>
implemented in the
<a href="https://easystats.github.io/see/"><span class="pkg">see</span>-package</a>. <strong>Please
note</strong> that the range of the distance-values along the y-axis is re-scaled
to range from 0 to 1.
</p>


<h3>References</h3>


<ul>
<li><p> Archimbaud, A., Nordhausen, K., and Ruiz-Gazen, A. (2018). ICS for
multivariate outlier detection with application to quality control.
Computational Statistics and Data Analysis, 128, 184-199.
doi: <a href="https://doi.org/10.1016/j.csda.2018.06.011">10.1016/j.csda.2018.06.011</a>
</p>
</li>
<li><p> Gnanadesikan, R., and Kettenring, J. R. (1972). Robust estimates, residuals,
and outlier detection with multiresponse data. Biometrics, 81-124.
</p>
</li>
<li><p> Bollen, K. A., and Jackman, R. W. (1985). Regression diagnostics: An
expository treatment of outliers and influential cases. Sociological Methods
and Research, 13(4), 510-542.
</p>
</li>
<li><p> Cabana, E., Lillo, R. E., and Laniado, H. (2019). Multivariate outlier
detection based on a robust Mahalanobis distance with shrinkage estimators.
arXiv preprint arXiv:1904.02596.
</p>
</li>
<li><p> Cook, R. D. (1977). Detection of influential observation in linear
regression. Technometrics, 19(1), 15-18.
</p>
</li>
<li><p> Iglewicz, B., and Hoaglin, D. C. (1993). How to detect and handle outliers
(Vol. 16). Asq Press.
</p>
</li>
<li><p> Leys, C., Klein, O., Dominicy, Y., and Ley, C. (2018). Detecting
multivariate outliers: Use a robust variant of Mahalanobis distance. Journal
of Experimental Social Psychology, 74, 150-156.
</p>
</li>
<li><p> Liu, F. T., Ting, K. M., and Zhou, Z. H. (2008, December). Isolation forest.
In 2008 Eighth IEEE International Conference on Data Mining (pp. 413-422).
IEEE.
</p>
</li>
<li><p> Lüdecke, D., Ben-Shachar, M. S., Patil, I., Waggoner, P., and Makowski, D.
(2021). performance: An R package for assessment, comparison and testing of
statistical models. Journal of Open Source Software, 6(60), 3139.
doi: <a href="https://doi.org/10.21105/joss.03139">10.21105/joss.03139</a>
</p>
</li>
<li><p> Thériault, R., Ben-Shachar, M. S., Patil, I., Lüdecke, D., Wiernik, B. M.,
and Makowski, D. (2023). Check your outliers! An introduction to identifying
statistical outliers in R with easystats. doi: <a href="https://doi.org/10.31234/osf.io/bu6nt">10.31234/osf.io/bu6nt</a>
</p>
</li>
<li><p> Rousseeuw, P. J., and Van Zomeren, B. C. (1990). Unmasking multivariate
outliers and leverage points. Journal of the American Statistical
association, 85(411), 633-639.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other functions to check model assumptions and and assess model quality: 
<code><a href="../../performance/help/check_autocorrelation.html">check_autocorrelation</a>()</code>,
<code><a href="../../performance/help/check_collinearity.html">check_collinearity</a>()</code>,
<code><a href="../../performance/help/check_convergence.html">check_convergence</a>()</code>,
<code><a href="../../performance/help/check_heteroscedasticity.html">check_heteroscedasticity</a>()</code>,
<code><a href="../../performance/help/check_homogeneity.html">check_homogeneity</a>()</code>,
<code><a href="../../performance/help/check_model.html">check_model</a>()</code>,
<code><a href="../../performance/help/check_overdispersion.html">check_overdispersion</a>()</code>,
<code><a href="../../performance/help/check_predictions.html">check_predictions</a>()</code>,
<code><a href="../../performance/help/check_singularity.html">check_singularity</a>()</code>,
<code><a href="../../performance/help/check_zeroinflation.html">check_zeroinflation</a>()</code>
</p>


<h3>Examples</h3>

<pre>
data &lt;- mtcars # Size nrow(data) = 32

# For single variables ------------------------------------------------------
outliers_list &lt;- check_outliers(data$mpg) # Find outliers
outliers_list # Show the row index of the outliers
as.numeric(outliers_list) # The object is a binary vector...
filtered_data &lt;- data[!outliers_list, ] # And can be used to filter a dataframe
nrow(filtered_data) # New size, 28 (4 outliers removed)

# Find all observations beyond +/- 2 SD
check_outliers(data$mpg, method = "zscore", threshold = 2)

# For dataframes ------------------------------------------------------
check_outliers(data) # It works the same way on dataframes

# You can also use multiple methods at once
outliers_list &lt;- check_outliers(data, method = c(
  "mahalanobis",
  "iqr",
  "zscore"
))
outliers_list

# Using `as.data.frame()`, we can access more details!
outliers_info &lt;- as.data.frame(outliers_list)
head(outliers_info)
outliers_info$Outlier # Including the probability of being an outlier

# And we can be more stringent in our outliers removal process
filtered_data &lt;- data[outliers_info$Outlier &lt; 0.1, ]

# We can run the function stratified by groups using `{datawizard}` package:
group_iris &lt;- datawizard::data_group(iris, "Species")
check_outliers(group_iris)



# You can also run all the methods
check_outliers(data, method = "all", verbose = FALSE)

# For statistical models ---------------------------------------------
# select only mpg and disp (continuous)
mt1 &lt;- mtcars[, c(1, 3, 4)]
# create some fake outliers and attach outliers to main df
mt2 &lt;- rbind(mt1, data.frame(
  mpg = c(37, 40), disp = c(300, 400),
  hp = c(110, 120)
))
# fit model with outliers
model &lt;- lm(disp ~ mpg + hp, data = mt2)

outliers_list &lt;- check_outliers(model)
plot(outliers_list)

insight::get_data(model)[outliers_list, ] # Show outliers data


</pre>

<hr /><div style="text-align: center;">[Package <em>performance</em> version 0.11.0 <a href="00Index.html">Index</a>]</div>
</div></body></html>
