<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Test if models are different</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body><div class="container">

<table width="100%" summary="page for test_bf {performance}"><tr><td>test_bf {performance}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Test if models are different</h2>

<h3>Description</h3>

<p>Testing whether models are &quot;different&quot; in terms of accuracy or explanatory
power is a delicate and often complex procedure, with many limitations and
prerequisites. Moreover, many tests exist, each coming with its own
interpretation, and set of strengths and weaknesses.
</p>
<p>The <code>test_performance()</code> function runs the most relevant and appropriate
tests based on the type of input (for instance, whether the models are
<em>nested</em> or not). However, it still requires the user to understand what the
tests are and what they do in order to prevent their misinterpretation. See
the <em>Details</em> section for more information regarding the different tests
and their interpretation.
</p>


<h3>Usage</h3>

<pre>
test_bf(...)

## Default S3 method:
test_bf(..., reference = 1, text_length = NULL)

test_likelihoodratio(..., estimator = "ML", verbose = TRUE)

test_lrt(..., estimator = "ML", verbose = TRUE)

test_performance(..., reference = 1, verbose = TRUE)

test_vuong(..., verbose = TRUE)

test_wald(..., verbose = TRUE)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>...</code></td>
<td>
<p>Multiple model objects.</p>
</td></tr>
<tr valign="top"><td><code>reference</code></td>
<td>
<p>This only applies when models are non-nested, and determines
which model should be taken as a reference, against which all the other
models are tested.</p>
</td></tr>
<tr valign="top"><td><code>text_length</code></td>
<td>
<p>Numeric, length (number of chars) of output lines.
<code>test_bf()</code> describes models by their formulas, which can lead to
overly long lines in the output. <code>text_length</code> fixes the length of
lines to a specified limit.</p>
</td></tr>
<tr valign="top"><td><code>estimator</code></td>
<td>
<p>Applied when comparing regression models using
<code>test_likelihoodratio()</code>. Corresponds to the different estimators for
the standard deviation of the errors. Defaults to <code>"OLS"</code> for linear models,
<code>"ML"</code> for all other models (including mixed models), or <code>"REML"</code> for
linear mixed models when these have the same fixed effects. See 'Details'.</p>
</td></tr>
<tr valign="top"><td><code>verbose</code></td>
<td>
<p>Toggle warning and messages.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Nested vs. Non-nested Models</h4>

<p>Model's &quot;nesting&quot; is an important concept of models comparison. Indeed, many
tests only make sense when the models are <em>&quot;nested&quot;,</em> i.e., when their
predictors are nested. This means that all the <em>fixed effects</em> predictors of
a model are contained within the <em>fixed effects</em> predictors of a larger model
(sometimes referred to as the encompassing model). For instance,
<code>model1 (y ~ x1 + x2)</code> is &quot;nested&quot; within <code>model2 (y ~ x1 + x2 + x3)</code>. Usually,
people have a list of nested models, for instance <code>m1 (y ~ 1)</code>, <code>m2 (y ~ x1)</code>,
<code>m3 (y ~ x1 + x2)</code>, <code>m4 (y ~ x1 + x2 + x3)</code>, and it is conventional
that they are &quot;ordered&quot; from the smallest to largest, but it is up to the
user to reverse the order from largest to smallest. The test then shows
whether a more parsimonious model, or whether adding a predictor, results in
a significant difference in the model's performance. In this case, models are
usually compared <em>sequentially</em>: m2 is tested against m1, m3 against m2,
m4 against m3, etc.
</p>
<p>Two models are considered as <em>&quot;non-nested&quot;</em> if their predictors are
different. For instance, <code>model1 (y ~ x1 + x2)</code> and <code>model2 (y ~ x3 + x4)</code>.
In the case of non-nested models, all models are usually compared
against the same <em>reference</em> model (by default, the first of the list).
</p>
<p>Nesting is detected via the <code>insight::is_nested_models()</code> function.
Note that, apart from the nesting, in order for the tests to be valid,
other requirements have often to be the fulfilled. For instance, outcome
variables (the response) must be the same. You cannot meaningfully test
whether apples are significantly different from oranges!
</p>



<h4>Estimator of the standard deviation</h4>

<p>The estimator is relevant when comparing regression models using
<code>test_likelihoodratio()</code>. If <code>estimator = "OLS"</code>, then it uses the same
method as <code>anova(..., test = "LRT")</code> implemented in base R, i.e., scaling
by n-k (the unbiased OLS estimator) and using this estimator under the
alternative hypothesis. If <code>estimator = "ML"</code>, which is for instance used
by <code>lrtest(...)</code> in package <strong>lmtest</strong>, the scaling is done by n (the
biased ML estimator) and the estimator under the null hypothesis. In
moderately large samples, the differences should be negligible, but it
is possible that OLS would perform slightly better in small samples with
Gaussian errors. For <code>estimator = "REML"</code>, the LRT is based on the REML-fit
log-likelihoods of the models. Note that not all types of estimators are
available for all model classes.
</p>



<h4>REML versus ML estimator</h4>

<p>When <code>estimator = "ML"</code>, which is the default for linear mixed models (unless
they share the same fixed effects), values from information criteria (AIC,
AICc) are based on the ML-estimator, while the default behaviour of <code>AIC()</code>
may be different (in particular for linear mixed models from <strong>lme4</strong>, which
sets <code>REML = TRUE</code>). This default in <code>test_likelihoodratio()</code> intentional,
because comparing information criteria based on REML fits requires the same
fixed effects for all models, which is often not the case. Thus, while
<code>anova.merMod()</code> automatically refits all models to REML when performing a
LRT, <code>test_likelihoodratio()</code> checks if a comparison based on REML fits is
indeed valid, and if so, uses REML as default (else, ML is the default).
Set the <code>estimator</code> argument explicitely to override the default behaviour.
</p>



<h4>Tests Description</h4>


<ul>
<li> <p><strong>Bayes factor for Model Comparison</strong> - <code>test_bf()</code>: If all
models were fit from the same data, the returned <code>BF</code> shows the Bayes
Factor (see <code>bayestestR::bayesfactor_models()</code>) for each model against
the reference model (which depends on whether the models are nested or
not). Check out
<a href="https://easystats.github.io/bayestestR/articles/bayes_factors.html#bayesfactor_models">this vignette</a>
for more details.
</p>
</li>
<li> <p><strong>Wald's F-Test</strong> - <code>test_wald()</code>: The Wald test is a rough
approximation of the Likelihood Ratio Test. However, it is more applicable
than the LRT: you can often run a Wald test in situations where no other
test can be run. Importantly, this test only makes statistical sense if the
models are nested.
</p>
<p>Note: this test is also available in base R
through the <code><a href="../../stats/html/anova.html">anova()</a></code> function. It returns an <code>F-value</code> column
as a statistic and its associated p-value.
</p>
</li>
<li> <p><strong>Likelihood Ratio Test (LRT)</strong> - <code>test_likelihoodratio()</code>:
The LRT tests which model is a better (more likely) explanation of the
data. Likelihood-Ratio-Test (LRT) gives usually somewhat close results (if
not equivalent) to the Wald test and, similarly, only makes sense for
nested models. However, maximum likelihood tests make stronger assumptions
than method of moments tests like the F-test, and in turn are more
efficient. Agresti (1990) suggests that you should use the LRT instead of
the Wald test for small sample sizes (under or about 30) or if the
parameters are large.
</p>
<p>Note: for regression models, this is similar to
<code>anova(..., test="LRT")</code> (on models) or <code>lmtest::lrtest(...)</code>, depending
on the <code>estimator</code> argument. For <strong>lavaan</strong> models (SEM, CFA), the function
calls <code>lavaan::lavTestLRT()</code>.
</p>
<p>For models with transformed response variables (like <code>log(x)</code> or <code>sqrt(x)</code>),
<code>logLik()</code> returns a wrong log-likelihood. However, <code>test_likelihoodratio()</code>
calls <code>insight::get_loglikelihood()</code> with <code>check_response=TRUE</code>, which
returns a corrected log-likelihood value for models with transformed
response variables. Furthermore, since the LRT only accepts nested
models (i.e. models that differ in their fixed effects), the computed
log-likelihood is always based on the ML estimator, not on the REML fits.
</p>
</li>
<li> <p><strong>Vuong's Test</strong> - <code>test_vuong()</code>: Vuong's (1989) test can
be used both for nested and non-nested models, and actually consists of two
tests.
</p>

<ul>
<li><p> The <strong>Test of Distinguishability</strong> (the <code>Omega2</code> column and
its associated p-value) indicates whether or not the models can possibly be
distinguished on the basis of the observed data. If its p-value is
significant, it means the models are distinguishable.
</p>
</li>
<li><p> The <strong>Robust Likelihood Test</strong> (the <code>LR</code> column and its
associated p-value) indicates whether each model fits better than the
reference model. If the models are nested, then the test works as a robust
LRT. The code for this function is adapted from the <strong>nonnest2</strong>
package, and all credit go to their authors.
</p>
</li></ul>

</li></ul>




<h3>Value</h3>

<p>A data frame containing the relevant indices.
</p>


<h3>References</h3>


<ul>
<li><p> Vuong, Q. H. (1989). Likelihood ratio tests for model selection and
non-nested hypotheses. Econometrica, 57, 307-333.
</p>
</li>
<li><p> Merkle, E. C., You, D., &amp; Preacher, K. (2016). Testing non-nested
structural equation models. Psychological Methods, 21, 151-163.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="../../performance/help/compare_performance.html">compare_performance()</a></code> to compare the performance indices of
many different models.
</p>


<h3>Examples</h3>

<pre>
# Nested Models
# -------------
m1 &lt;- lm(Sepal.Length ~ Petal.Width, data = iris)
m2 &lt;- lm(Sepal.Length ~ Petal.Width + Species, data = iris)
m3 &lt;- lm(Sepal.Length ~ Petal.Width * Species, data = iris)

test_performance(m1, m2, m3)

test_bf(m1, m2, m3)
test_wald(m1, m2, m3) # Equivalent to anova(m1, m2, m3)

# Equivalent to lmtest::lrtest(m1, m2, m3)
test_likelihoodratio(m1, m2, m3, estimator = "ML")

# Equivalent to anova(m1, m2, m3, test='LRT')
test_likelihoodratio(m1, m2, m3, estimator = "OLS")

if (require("CompQuadForm")) {
  test_vuong(m1, m2, m3) # nonnest2::vuongtest(m1, m2, nested=TRUE)

  # Non-nested Models
  # -----------------
  m1 &lt;- lm(Sepal.Length ~ Petal.Width, data = iris)
  m2 &lt;- lm(Sepal.Length ~ Petal.Length, data = iris)
  m3 &lt;- lm(Sepal.Length ~ Species, data = iris)

  test_performance(m1, m2, m3)
  test_bf(m1, m2, m3)
  test_vuong(m1, m2, m3) # nonnest2::vuongtest(m1, m2)
}

# Tweak the output
# ----------------
test_performance(m1, m2, m3, include_formula = TRUE)


# SEM / CFA (lavaan objects)
# --------------------------
# Lavaan Models
if (require("lavaan")) {
  structure &lt;- " visual  =~ x1 + x2 + x3
                 textual =~ x4 + x5 + x6
                 speed   =~ x7 + x8 + x9

                  visual ~~ textual + speed "
  m1 &lt;- lavaan::cfa(structure, data = HolzingerSwineford1939)

  structure &lt;- " visual  =~ x1 + x2 + x3
                 textual =~ x4 + x5 + x6
                 speed   =~ x7 + x8 + x9

                  visual ~~ 0 * textual + speed "
  m2 &lt;- lavaan::cfa(structure, data = HolzingerSwineford1939)

  structure &lt;- " visual  =~ x1 + x2 + x3
                 textual =~ x4 + x5 + x6
                 speed   =~ x7 + x8 + x9

                  visual ~~ 0 * textual + 0 * speed "
  m3 &lt;- lavaan::cfa(structure, data = HolzingerSwineford1939)

  test_likelihoodratio(m1, m2, m3)

  # Different Model Types
  # ---------------------
  if (require("lme4") &amp;&amp; require("mgcv")) {
    m1 &lt;- lm(Sepal.Length ~ Petal.Length + Species, data = iris)
    m2 &lt;- lmer(Sepal.Length ~ Petal.Length + (1 | Species), data = iris)
    m3 &lt;- gam(Sepal.Length ~ s(Petal.Length, by = Species) + Species, data = iris)

    test_performance(m1, m2, m3)
  }
}

</pre>

<hr /><div style="text-align: center;">[Package <em>performance</em> version 0.11.0 <a href="00Index.html">Index</a>]</div>
</div></body></html>
