<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Make circular heatmaps</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body><div class="container">

<table width="100%" summary="page for circos.heatmap {circlize}"><tr><td>circos.heatmap {circlize}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>
Make circular heatmaps
</h2>

<h3>Description</h3>

<p>Make circular heatmaps
</p>


<h3>Usage</h3>

<pre>
circos.heatmap(mat, split = NULL, col, na.col = "grey",
    cell.border = NA, cell.lty = 1, cell.lwd = 1,
    bg.border = NA, bg.lty = par("lty"), bg.lwd = par("lwd"),
    ignore.white = is.na(cell.border),
    cluster = TRUE, clustering.method = "complete", distance.method = "euclidean",
    dend.callback = function(dend, m, si) reorder(dend, rowMeans(m)),
    dend.side = c("none", "outside", "inside"), dend.track.height = 0.1,
    rownames.side = c("none", "outside", "inside"), rownames.cex = 0.5,
    rownames.font = par("font"), rownames.col = "black",
    show.sector.labels = FALSE, cell_width = rep(1, nrow(mat)), ...)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>mat</code></td>
<td>
<p>A matrix or a vector. The vector is transformed as a one-column matrix.</p>
</td></tr>
<tr valign="top"><td><code>split</code></td>
<td>
<p>A categorical variable. It splits the matrix into a list of matrices.</p>
</td></tr>
<tr valign="top"><td><code>col</code></td>
<td>
<p>If the values in the matrices are continuous, the color should be a color mapping generated by  <code><a href="../../circlize/help/colorRamp2.html">colorRamp2</a></code>. If the values are characters, the color should be a named color vector.</p>
</td></tr>
<tr valign="top"><td><code>na.col</code></td>
<td>
<p>Color for <code>NA</code> values.</p>
</td></tr>
<tr valign="top"><td><code>cell.border</code></td>
<td>
<p>Border color of cells. A single scalar.</p>
</td></tr>
<tr valign="top"><td><code>cell.lty</code></td>
<td>
<p>Line type of cell borders. A single scalar.</p>
</td></tr>
<tr valign="top"><td><code>cell.lwd</code></td>
<td>
<p>Line width of cell borders. A single scalar.</p>
</td></tr>
<tr valign="top"><td><code>bg.border</code></td>
<td>
<p>Color for background border.</p>
</td></tr>
<tr valign="top"><td><code>bg.lty</code></td>
<td>
<p>Line type of the background border.</p>
</td></tr>
<tr valign="top"><td><code>bg.lwd</code></td>
<td>
<p>Line width of the background border.</p>
</td></tr>
<tr valign="top"><td><code>ignore.white</code></td>
<td>
<p>Whether to draw the white color?</p>
</td></tr>
<tr valign="top"><td><code>cluster</code></td>
<td>
<p>whether to apply clustering on rows. The value can also be a <code>dendrogram</code>/<code>hclust</code> object or other objects that can be converted to with <code><a href="../../stats/help/dendrogram.html">as.dendrogram</a></code>.</p>
</td></tr>
<tr valign="top"><td><code>clustering.method</code></td>
<td>
<p>Clustering method, pass to <code><a href="../../stats/help/hclust.html">hclust</a></code>.</p>
</td></tr>
<tr valign="top"><td><code>distance.method</code></td>
<td>
<p>Distance method, pass to <code><a href="../../stats/help/dist.html">dist</a></code>.</p>
</td></tr>
<tr valign="top"><td><code>dend.callback</code></td>
<td>
<p>A callback function that is applied to the dendrogram in every sector.</p>
</td></tr>
<tr valign="top"><td><code>dend.side</code></td>
<td>
<p>Side of the dendrograms relative to the heatmap track.</p>
</td></tr>
<tr valign="top"><td><code>dend.track.height</code></td>
<td>
<p>Track height of the dendrograms.</p>
</td></tr>
<tr valign="top"><td><code>rownames.side</code></td>
<td>
<p>Side of the row names relative to the heatmap track.</p>
</td></tr>
<tr valign="top"><td><code>rownames.cex</code></td>
<td>
<p>Cex of row names.</p>
</td></tr>
<tr valign="top"><td><code>rownames.font</code></td>
<td>
<p>Font of row names.</p>
</td></tr>
<tr valign="top"><td><code>rownames.col</code></td>
<td>
<p>Color of row names.</p>
</td></tr>
<tr valign="top"><td><code>show.sector.labels</code></td>
<td>
<p>Whether to show sector labels.</p>
</td></tr>
<tr valign="top"><td><code>cell_width</code></td>
<td>
<p>Relative widths of heatmap cells.</p>
</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>
<p>Pass to <code><a href="../../circlize/help/circos.track.html">circos.track</a></code> which draws the heatmap track.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="https://jokergoo.github.io/2020/05/21/make-circular-heatmaps/">https://jokergoo.github.io/2020/05/21/make-circular-heatmaps/</a>
</p>


<h3>Examples</h3>

<pre>

set.seed(123)
mat1 = rbind(cbind(matrix(rnorm(50*5, mean = 1), nr = 50), 
                   matrix(rnorm(50*5, mean = -1), nr = 50)),
             cbind(matrix(rnorm(50*5, mean = -1), nr = 50), 
                   matrix(rnorm(50*5, mean = 1), nr = 50))
            )
rownames(mat1) = paste0("R", 1:100)
colnames(mat1) = paste0("C", 1:10)
mat1 = mat1[sample(100, 100), ] # randomly permute rows
split = sample(letters[1:5], 100, replace = TRUE)
spilt = factor(split, levels = letters[1:5])
col_fun1 = colorRamp2(c(-2, 0, 2), c("blue", "white", "red"))
circos.heatmap(mat1, split = split, col = col_fun1)
circos.clear()

</pre>

<hr /><div style="text-align: center;">[Package <em>circlize</em> version 0.4.16 <a href="00Index.html">Index</a>]</div>
</div></body></html>
